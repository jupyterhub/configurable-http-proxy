#!/usr/bin/env node
//
// cli entrypoint for starting a Configurable Proxy
// 
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.
//

"use strict";

var fs = require('fs'),
    args = require('commander'),
    strftime = require('strftime'),
    log = require('winston');

args
    .version('0.5.0-dev')
    // .option('-h', '--help', 'show help')
    .option('--ip <n>', 'Public-facing IP of the proxy')
    .option('--port <n>', 'Public-facing port of the proxy', parseInt)
    .option('--ssl-key <keyfile>', 'SSL key to use, if any')
    .option('--ssl-cert <certfile>', 'SSL certificate to use, if any')
    .option('--api-ip <ip>', 'Inward-facing IP for API requests', 'localhost')
    .option('--api-port <n>', 'Inward-facing port for API requests', parseInt)
    .option('--api-ssl-key <keyfile>', 'SSL key to use, if any, for API requests')
    .option('--api-ssl-cert <certfile>', 'SSL certificate to use, if any, for API requests')
    .option('--default-target <host>', 'Default proxy target (proto://host[:port]')
    .option('--error-target <host>', 'Alternate server for handling proxy errors (proto://host[:port]')
    .option('--error-path <path>', 'Alternate server for handling proxy errors (proto://host[:port]')
    .option('--redirect-port <redirect-port>', 'Redirect HTTP requests on this port to the server on HTTPS')
    // passthrough http-proxy options
    .option('--no-x-forward', "Don't add 'X-forward-' headers to proxied requests")
    .option('--no-prepend-path', "Avoid prepending target paths to proxied requests")
    .option('--no-include-prefix', "Don't include the routing prefix in proxied requests")
    .option('--insecure', "Disable SSL cert verification")
    .option('--host-routing', "Use host routing (host as first level of path)")
    .option('--log-level <loglevel>', 'Log level (debug, info, warn, error)', 'info');

args.parse(process.argv);

log.remove(log.transports.Console);
log.add(log.transports.Console, {
    colorize: (process.stdout.isTTY && process.stderr.isTTY),
    level: args.logLevel.toLowerCase(),
    timestamp: function () {
      return strftime("%H:%M:%S.%L", new Date());
    },
    label: 'ConfigProxy',
});

var ConfigurableProxy = require('../lib/configproxy.js').ConfigurableProxy;

var options = {};

// ssl options
if (args.sslKey || args.sslCert) {
    options.ssl = {};
    if (args.sslKey) {
        options.ssl.key = fs.readFileSync(args.sslKey);
    }
    if (args.sslCert) {
        options.ssl.cert = fs.readFileSync(args.sslCert);
    }
}

// ssl options for the API interface
if (args.apiSslKey || args.apiSslCert) {
    options.api_ssl = {};
    if (args.apiSslKey) {
        options.api_ssl.key = fs.readFileSync(args.apiSslKey);
    }
    if (args.apiSslCert) {
        options.api_ssl.cert = fs.readFileSync(args.apiSslCert);
    }
}

// because camelCase is the js way!
options.default_target = args.defaultTarget;
options.error_target = args.errorTarget;
options.error_path = args.errorPath;
options.host_routing = args.hostRouting;
options.auth_token = process.env.CONFIGPROXY_AUTH_TOKEN;
options.redirectPort = args.redirectPort;

// certs need to be provided for https redirection
if (!options.ssl && options.redirectPort) {
    log.error("HTTPS redirection specified but certificates not provided.");
    process.exit(1);
}

if (options.error_target && options.error_path) {
    log.error("Cannot specify both error-target and error-path. Pick one.");
    process.exit(1);
}

// passthrough for http-proxy options
if (args.insecure) options.secure = false;
options.xfwd = args.noXHeaders ? false : true;
options.prependPath = args.prependPath;
options.includePrefix = args.includePrefix;

if (!options.auth_token) {
    log.warn("REST API is not authenticated.");
}

var proxy = new ConfigurableProxy(options);

var listen = {};
listen.port = parseInt(args.port) || 8000;
listen.ip = args.ip;
listen.api_ip = args.apiIp || 'localhost';
listen.api_port = args.apiPort || listen.port + 1;

proxy.proxy_server.listen(listen.port, listen.ip);
proxy.api_server.listen(listen.api_port, listen.api_ip);

log.info("Proxying %s://%s:%s to %s",
    options.ssl ? 'https' : 'http',
    (listen.ip || '*'), listen.port,
    options.default_target || "(no default)"
);
log.info("Proxy API at %s://%s:%s/api/routes",
    options.api_ssl ? 'https' : 'http',
    (listen.api_ip || '*'),
    listen.api_port);

// Redirect HTTP to HTTPS on the proxy's port
if (options.redirectPort && listen.port !== 80) {
  var http = require('http');
  
  http.createServer(function (req, res) {
    var host = req.headers['host'].split(':')[0];
    
    // Make sure that when we redirect, it's to the port the proxy is running on
    if (listen.port !== 443) {
        host = host + ':' + listen.port;
    }
    res.writeHead(301, { "Location": "https://" + host + req.url });
    res.end();
  }).listen(options.redirectPort);
}
